{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-log Zend\\Log is a component for general purpose logging. It supports multiple log backends, formatting messages sent to the log, and filtering messages from being logged. Installation Run the following to install this library: $ composer require zendframework/zend-log Documentation Browse the documentation online at https://docs.zendframework.com/zend-log/ Support Issues Chat Forum","title":"Home"},{"location":"#zend-log","text":"Zend\\Log is a component for general purpose logging. It supports multiple log backends, formatting messages sent to the log, and filtering messages from being logged.","title":"zend-log"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-log","title":"Installation"},{"location":"#documentation","text":"Browse the documentation online at https://docs.zendframework.com/zend-log/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"filters/","text":"Filters A filter prevents a message from being written to the log. You can add a filter to a specific writer using the addFilter() method of the writer: use Zend\\Log\\Logger; $logger = new Logger(); $writer1 = new Zend\\Log\\Writer\\Stream('/path/to/first/logfile'); $logger->addWriter($writer1); $writer2 = new Zend\\Log\\Writer\\Stream('/path/to/second/logfile'); $logger->addWriter($writer2); // add a filter only to writer2 $filter = new Zend\\Log\\Filter\\Priority(Logger::CRIT); $writer2->addFilter($filter); // logged to writer1, blocked from writer2 $logger->info('Informational message'); // logged by both writers $logger->emerg('Emergency message'); Available filters Filter Class Short Name Description Zend\\Log\\Filter\\Priority Priority Filter logging by $priority . By default, it will accept any log event whose priority value is less than or equal to $priority . Zend\\Log\\Filter\\Regex Regex Filter out any log messages not matching the regex pattern. This filter uses the preg_match() function. Zend\\Log\\Filter\\Timestamp Timestamp Filters log events based on the time when they were triggered. It can be configured by specifying either idate() -compliant format characters along with the desired value, or a full DateTime instance. An appropriate comparison operator must be supplied in either case. Zend\\Log\\Filter\\SuppressFilter SuppressFilter A simple boolean filter; a boolean true value passed to the constructor suppresses all log events, while a boolean false value accepts all log events. Zend\\Log\\Filter\\Validator Validator Filter any log messages that fail validaton by the composed Zend\\Validator\\ValidatorInterface implementation.","title":"Filters"},{"location":"filters/#filters","text":"A filter prevents a message from being written to the log. You can add a filter to a specific writer using the addFilter() method of the writer: use Zend\\Log\\Logger; $logger = new Logger(); $writer1 = new Zend\\Log\\Writer\\Stream('/path/to/first/logfile'); $logger->addWriter($writer1); $writer2 = new Zend\\Log\\Writer\\Stream('/path/to/second/logfile'); $logger->addWriter($writer2); // add a filter only to writer2 $filter = new Zend\\Log\\Filter\\Priority(Logger::CRIT); $writer2->addFilter($filter); // logged to writer1, blocked from writer2 $logger->info('Informational message'); // logged by both writers $logger->emerg('Emergency message');","title":"Filters"},{"location":"filters/#available-filters","text":"Filter Class Short Name Description Zend\\Log\\Filter\\Priority Priority Filter logging by $priority . By default, it will accept any log event whose priority value is less than or equal to $priority . Zend\\Log\\Filter\\Regex Regex Filter out any log messages not matching the regex pattern. This filter uses the preg_match() function. Zend\\Log\\Filter\\Timestamp Timestamp Filters log events based on the time when they were triggered. It can be configured by specifying either idate() -compliant format characters along with the desired value, or a full DateTime instance. An appropriate comparison operator must be supplied in either case. Zend\\Log\\Filter\\SuppressFilter SuppressFilter A simple boolean filter; a boolean true value passed to the constructor suppresses all log events, while a boolean false value accepts all log events. Zend\\Log\\Filter\\Validator Validator Filter any log messages that fail validaton by the composed Zend\\Validator\\ValidatorInterface implementation.","title":"Available filters"},{"location":"formatters/","text":"Formatters A formatter is an object that is responsible for taking an event array describing a log event and outputting a string with a formatted log line. Some writers are not line-oriented, such as the Db , FirePhp , and ChromePhp writers. For these writers, formatters ensure the individual values in the event array are formatted properly for the writer. Simple Formatting Zend\\Log\\Formatter\\Simple is the default formatter. It is configured automatically when you specify no formatter. The default configuration is equivalent to the following: $format = '%timestamp% %priorityName% (%priority%): %message%' . PHP_EOL; $formatter = new Zend\\Log\\Formatter\\Simple($format); A formatter is set on an individual writer object using the writer's setFormatter() method: $writer = new Zend\\Log\\Writer\\Stream('php://output'); $formatter = new Zend\\Log\\Formatter\\Simple('hello %message%' . PHP_EOL); $writer->setFormatter($formatter); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('there'); // outputs \"hello there\" The constructor of Zend\\Log\\Formatter\\Simple accepts a single parameter: the format string. This string contains keys surrounded by percent signs (e.g. %message% ). The format string may contain any key from the event data array. You can retrieve the default keys by using the DEFAULT_FORMAT constant from Zend\\Log\\Formatter\\Simple . Formatting to JSON Zend\\Log\\Formatter\\Json is the JSON formatter. By default, it automatically logs all items as JSON: $writer = new Zend\\Log\\Writer\\Stream('php://output'); $formatter = new Zend\\Log\\Formatter\\Json(); $writer->setFormatter($formatter); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('there'); // outputs \"{\"timestamp\":\"2016-09-07T13:58:01+00:00\",\"priority\":6,\"priorityName\":\"INFO\",\"message\":\"there\",\"extra\":[]}\" Formatting to XML Zend\\Log\\Formatter\\Xml formats log data into XML strings. By default, it automatically logs all items in the event array: $writer = new Zend\\Log\\Writer\\Stream('php://output'); $formatter = new Zend\\Log\\Formatter\\Xml(); $writer->setFormatter($formatter); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('informational message'); The code above outputs the following XML (space added for clarity): <logEntry> <timestamp>2007-04-06T07:24:37-07:00</timestamp> <message>informational message</message> <priority>6</priority> <priorityName>INFO</priorityName> </logEntry> It's possible to customize the root element, as well as specify a mapping of XML elements to the items in the event data array. The constructor of Zend\\Log\\Formatter\\Xml accepts a string with the name of the root element as the first parameter, and an associative array with the element mapping as the second parameter: $writer = new Zend\\Log\\Writer\\Stream('php://output'); $formatter = new Zend\\Log\\Formatter\\Xml('log', [ 'msg' => 'message', 'level' => 'priorityName', ]); $writer->setFormatter($formatter); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('informational message'); The code above changes the root element from its default of logEntry to log . It also maps the element msg to the event data item message . This results in the following output: <log> <msg>informational message</msg> <level>INFO</level> </log> Formatting to FirePhp Zend\\Log\\Formatter\\FirePhp formats log data for the Firebug extension for Firefox.","title":"Formatters"},{"location":"formatters/#formatters","text":"A formatter is an object that is responsible for taking an event array describing a log event and outputting a string with a formatted log line. Some writers are not line-oriented, such as the Db , FirePhp , and ChromePhp writers. For these writers, formatters ensure the individual values in the event array are formatted properly for the writer.","title":"Formatters"},{"location":"formatters/#simple-formatting","text":"Zend\\Log\\Formatter\\Simple is the default formatter. It is configured automatically when you specify no formatter. The default configuration is equivalent to the following: $format = '%timestamp% %priorityName% (%priority%): %message%' . PHP_EOL; $formatter = new Zend\\Log\\Formatter\\Simple($format); A formatter is set on an individual writer object using the writer's setFormatter() method: $writer = new Zend\\Log\\Writer\\Stream('php://output'); $formatter = new Zend\\Log\\Formatter\\Simple('hello %message%' . PHP_EOL); $writer->setFormatter($formatter); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('there'); // outputs \"hello there\" The constructor of Zend\\Log\\Formatter\\Simple accepts a single parameter: the format string. This string contains keys surrounded by percent signs (e.g. %message% ). The format string may contain any key from the event data array. You can retrieve the default keys by using the DEFAULT_FORMAT constant from Zend\\Log\\Formatter\\Simple .","title":"Simple Formatting"},{"location":"formatters/#formatting-to-json","text":"Zend\\Log\\Formatter\\Json is the JSON formatter. By default, it automatically logs all items as JSON: $writer = new Zend\\Log\\Writer\\Stream('php://output'); $formatter = new Zend\\Log\\Formatter\\Json(); $writer->setFormatter($formatter); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('there'); // outputs \"{\"timestamp\":\"2016-09-07T13:58:01+00:00\",\"priority\":6,\"priorityName\":\"INFO\",\"message\":\"there\",\"extra\":[]}\"","title":"Formatting to JSON"},{"location":"formatters/#formatting-to-xml","text":"Zend\\Log\\Formatter\\Xml formats log data into XML strings. By default, it automatically logs all items in the event array: $writer = new Zend\\Log\\Writer\\Stream('php://output'); $formatter = new Zend\\Log\\Formatter\\Xml(); $writer->setFormatter($formatter); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('informational message'); The code above outputs the following XML (space added for clarity): <logEntry> <timestamp>2007-04-06T07:24:37-07:00</timestamp> <message>informational message</message> <priority>6</priority> <priorityName>INFO</priorityName> </logEntry> It's possible to customize the root element, as well as specify a mapping of XML elements to the items in the event data array. The constructor of Zend\\Log\\Formatter\\Xml accepts a string with the name of the root element as the first parameter, and an associative array with the element mapping as the second parameter: $writer = new Zend\\Log\\Writer\\Stream('php://output'); $formatter = new Zend\\Log\\Formatter\\Xml('log', [ 'msg' => 'message', 'level' => 'priorityName', ]); $writer->setFormatter($formatter); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('informational message'); The code above changes the root element from its default of logEntry to log . It also maps the element msg to the event data item message . This results in the following output: <log> <msg>informational message</msg> <level>INFO</level> </log>","title":"Formatting to XML"},{"location":"formatters/#formatting-to-firephp","text":"Zend\\Log\\Formatter\\FirePhp formats log data for the Firebug extension for Firefox.","title":"Formatting to FirePhp"},{"location":"intro/","text":"Overview Zend\\Log\\Logger is a component for general purpose logging. It supports multiple log backends, formatting messages sent to the log, and filtering messages from being logged. These functions are divided into the following objects: A logger (instance of Zend\\Log\\Logger ) is the object that your application uses the most. You can have as many logger objects as you like; they do not interact. A logger object must contain at least one writer , and can optionally contain one or more filters . A writer (inherits from Zend\\Log\\Writer\\AbstractWriter ) writes data to an underlying storage implementation. A filter (implements Zend\\Log\\Filter\\FilterInterface ) filters (blocks) log data from being saved. A filter is applied to an individual writer. Filters can be chained. A formatter (implements Zend\\Log\\Formatter\\FormatterInterface ) formats the log data before it is written by a writer. Each writer has exactly one formatter. A processor (implements Zend\\Log\\Processor\\ProcessorInterface ) processes the log event prior to filtering or writing, allowing the ability to substitute, add, remove, or modify data to be logged. Creating a Log To get started logging, instantiate a writer and then pass it to a logger instance: $logger = new Zend\\Log\\Logger; $writer = new Zend\\Log\\Writer\\Stream('php://output'); $logger->addWriter($writer); It is important to note that the logger must have at least one writer. You can add any number of writers using the logger's addWriter() method. You can also add a priority to each writer. The priority is specified as an integer and passed as the second argument in the addWriter() method. Another way to add a writer to a logger is to use the name of the writer as follow: $logger = new Zend\\Log\\Logger; $logger->addWriter('stream', null, ['stream' => 'php://output']); In this example we passed the stream php://output as a parameter (via an options array). Logging Messages To log a message, call the log() method of a Logger instance and pass it the message priority and the message: $logger->log(Zend\\Log\\Logger::INFO, 'Informational message'); The first parameter of the log() method is the integer priority and the second parameter is the string message . The priority must be one of the priorities recognized by the Logger instance (explained in the next section). There is also an optional third parameter used to pass extra information/metadata to the writer. Instead of using the log() method, you can optionally call methods named after the various supported priorities, which allows you to omit the priority argument: $logger->log(Zend\\Log\\Logger::INFO, 'Informational message'); $logger->info('Informational message'); $logger->log(Zend\\Log\\Logger::EMERG, 'Emergency message'); $logger->emerg('Emergency message'); Destroying a Log If the Logger instance is no longer needed, set the variable containing it to NULL to destroy it. This will automatically call the shutdown() instance method of each attached writer before the Logger instance is destroyed. $logger = null; Explicitly destroying the log in this way is optional and is performed automatically at PHP shutdown. Using Built-in Priorities The Zend\\Log\\Logger class defines the following priorities: EMERG = 0; // Emergency: system is unusable ALERT = 1; // Alert: action must be taken immediately CRIT = 2; // Critical: critical conditions ERR = 3; // Error: error conditions WARN = 4; // Warning: warning conditions NOTICE = 5; // Notice: normal but significant condition INFO = 6; // Informational: informational messages DEBUG = 7; // Debug: debug messages These priorities are always available, and a convenience method of the same name (but lowercased) is available for each one. The priorities are not arbitrary. They come from the BSD syslog protocol, which is described in RFC-3164 . The names and corresponding priority numbers are also compatible with another PHP logging system, PEAR Log , which perhaps promotes interoperability between it and Zend\\Log\\Logger ; PSR-3 uses similar semantics, but without the explicit priority integers. Priority numbers descend in order of importance. EMERG (0) is the most important priority. DEBUG (7) is the least important priority of the built-in priorities. You may define priorities of lower importance than DEBUG . When selecting the priority for your log message, be aware of this priority hierarchy and choose appropriately. Understanding Log Events When you call the log() method or one of its shortcuts, a log event is created. This is simply an associative array with data describing the event that is passed to the writers. The following keys are always created in this array: timestamp message priority priorityName The creation of the event array is an internal detail of implementation. Log PHP Errors Zend\\Log\\Logger can also be used to log PHP errors and intercept exceptions. Calling the static method registerErrorHandler($logger) will register the $logger instance to log errors; it returns a boolean false ensuring that it returns delegation to any other error handlers registered, including the default PHP error handler. $logger = new Zend\\Log\\Logger; $writer = new Zend\\Log\\Writer\\Stream('php://output'); $logger->addWriter($writer); Zend\\Log\\Logger::registerErrorHandler($logger); If you want to unregister the error handler, can use the unregisterErrorHandler() static method. You can also configure a logger to intercept exceptions using the static method registerExceptionHandler($logger) .","title":"Introduction"},{"location":"intro/#overview","text":"Zend\\Log\\Logger is a component for general purpose logging. It supports multiple log backends, formatting messages sent to the log, and filtering messages from being logged. These functions are divided into the following objects: A logger (instance of Zend\\Log\\Logger ) is the object that your application uses the most. You can have as many logger objects as you like; they do not interact. A logger object must contain at least one writer , and can optionally contain one or more filters . A writer (inherits from Zend\\Log\\Writer\\AbstractWriter ) writes data to an underlying storage implementation. A filter (implements Zend\\Log\\Filter\\FilterInterface ) filters (blocks) log data from being saved. A filter is applied to an individual writer. Filters can be chained. A formatter (implements Zend\\Log\\Formatter\\FormatterInterface ) formats the log data before it is written by a writer. Each writer has exactly one formatter. A processor (implements Zend\\Log\\Processor\\ProcessorInterface ) processes the log event prior to filtering or writing, allowing the ability to substitute, add, remove, or modify data to be logged.","title":"Overview"},{"location":"intro/#creating-a-log","text":"To get started logging, instantiate a writer and then pass it to a logger instance: $logger = new Zend\\Log\\Logger; $writer = new Zend\\Log\\Writer\\Stream('php://output'); $logger->addWriter($writer); It is important to note that the logger must have at least one writer. You can add any number of writers using the logger's addWriter() method. You can also add a priority to each writer. The priority is specified as an integer and passed as the second argument in the addWriter() method. Another way to add a writer to a logger is to use the name of the writer as follow: $logger = new Zend\\Log\\Logger; $logger->addWriter('stream', null, ['stream' => 'php://output']); In this example we passed the stream php://output as a parameter (via an options array).","title":"Creating a Log"},{"location":"intro/#logging-messages","text":"To log a message, call the log() method of a Logger instance and pass it the message priority and the message: $logger->log(Zend\\Log\\Logger::INFO, 'Informational message'); The first parameter of the log() method is the integer priority and the second parameter is the string message . The priority must be one of the priorities recognized by the Logger instance (explained in the next section). There is also an optional third parameter used to pass extra information/metadata to the writer. Instead of using the log() method, you can optionally call methods named after the various supported priorities, which allows you to omit the priority argument: $logger->log(Zend\\Log\\Logger::INFO, 'Informational message'); $logger->info('Informational message'); $logger->log(Zend\\Log\\Logger::EMERG, 'Emergency message'); $logger->emerg('Emergency message');","title":"Logging Messages"},{"location":"intro/#destroying-a-log","text":"If the Logger instance is no longer needed, set the variable containing it to NULL to destroy it. This will automatically call the shutdown() instance method of each attached writer before the Logger instance is destroyed. $logger = null; Explicitly destroying the log in this way is optional and is performed automatically at PHP shutdown.","title":"Destroying a Log"},{"location":"intro/#using-built-in-priorities","text":"The Zend\\Log\\Logger class defines the following priorities: EMERG = 0; // Emergency: system is unusable ALERT = 1; // Alert: action must be taken immediately CRIT = 2; // Critical: critical conditions ERR = 3; // Error: error conditions WARN = 4; // Warning: warning conditions NOTICE = 5; // Notice: normal but significant condition INFO = 6; // Informational: informational messages DEBUG = 7; // Debug: debug messages These priorities are always available, and a convenience method of the same name (but lowercased) is available for each one. The priorities are not arbitrary. They come from the BSD syslog protocol, which is described in RFC-3164 . The names and corresponding priority numbers are also compatible with another PHP logging system, PEAR Log , which perhaps promotes interoperability between it and Zend\\Log\\Logger ; PSR-3 uses similar semantics, but without the explicit priority integers. Priority numbers descend in order of importance. EMERG (0) is the most important priority. DEBUG (7) is the least important priority of the built-in priorities. You may define priorities of lower importance than DEBUG . When selecting the priority for your log message, be aware of this priority hierarchy and choose appropriately.","title":"Using Built-in Priorities"},{"location":"intro/#understanding-log-events","text":"When you call the log() method or one of its shortcuts, a log event is created. This is simply an associative array with data describing the event that is passed to the writers. The following keys are always created in this array: timestamp message priority priorityName The creation of the event array is an internal detail of implementation.","title":"Understanding Log Events"},{"location":"intro/#log-php-errors","text":"Zend\\Log\\Logger can also be used to log PHP errors and intercept exceptions. Calling the static method registerErrorHandler($logger) will register the $logger instance to log errors; it returns a boolean false ensuring that it returns delegation to any other error handlers registered, including the default PHP error handler. $logger = new Zend\\Log\\Logger; $writer = new Zend\\Log\\Writer\\Stream('php://output'); $logger->addWriter($writer); Zend\\Log\\Logger::registerErrorHandler($logger); If you want to unregister the error handler, can use the unregisterErrorHandler() static method. You can also configure a logger to intercept exceptions using the static method registerExceptionHandler($logger) .","title":"Log PHP Errors"},{"location":"processors/","text":"Processors Processors allow you to provide additional information to logs in an automated fashion. They are called from the logger before the event is passed to the writers; they receive the event array, and return an event array on completion. Use cases include: Providing exception backtrace information. Injecting substitutions into the message. Injecting a request identifier (in order to later inspect logs for a specific identifier) Processor interface All processors must implement Zend\\Log\\Processor\\ProcessorInterface : namespace Zend\\Log\\Processor; interface ProcessorInterface { /** * Processes a log message before it is given to the writers * * @param array $event * @return array */ public function process(array $event); } Adding processors To add a processor to a Logger instance, inject it using the addProcessor() method: $logger->addProcessor(new Zend\\Log\\Processor\\Backtrace()); Available processors The following processors are available. Backtrace Zend\\Log\\Processor\\Backtrace calls debug_backtrace() for every log event, injecting the details into the event's extra array: $event = [ // ... standard elements ... 'extra' => [ 'file' => 'SomeFile.php', 'line' => 1337, 'class' => 'Foo\\MyClass', 'function' => 'myMethod', ], ]; By default, classes under the Zend\\Log namespace are excluded from the backtrace that is logged so that the actual application code triggering the log event can be identified. You can add your own excluded namespaces to the backtrace processor by passing options into the constructor (note the required escaping of the \\ ): $processor = new Zend\\Log\\Processor\\Backtrace(['ignoredNamespaces' => ['Foo\\\\Log']]); $logger->addProcessor($processor); Alternatively, if not separately instantiating the processor, these options can be passed as the third argument to the logger's addProcessor() function: // Assuming the default processor priority of 1 $logger->addProcessor('backtrace', 1, ['ignoredNamespaces' => ['Foo\\\\Log']]); PsrPlaceholder Zend\\Log\\Processor\\PsrPlaceholder replaces PSR-3 -formatted message placeholders with the values found in the extra array. As an example: $logger->addProcessor(new Zend\\Log\\Processor\\PsrPlaceholder()); $logger->warn('Invalid plugin {plugin}', ['plugin' => 'My\\Plugins\\FooPlugin']); will output: Invalid plugin My\\Plugins\\FooPlugin This feature allows compatibility with PSR-3, and provides a simple way to provide string substitutions without needing to resort to sprintf() in your userland code. ReferenceId Zend\\Log\\Processor\\ReferenceId allows you to specify a static reference identifier to inject in all log messages; typically, you will generate a new one for each request, to allow querying logs for the given reference identifier later. Given the following: $processor = new Zend\\Log\\Processor\\ReferenceId(); $processor->setIdentifier(microtime(true) . '_' . uniqid()); $logger->addProcessor($processor); $logger->info('Log event'); The event will contain: $event = [ /* ... standard values ... */ 'extra' => [ 'referenceId' => '1455057110.6284_56ba68ebe1244', ], ]; RequestId Zend\\Log\\Processor\\RequestId is similar to ReferenceId with one key difference: if you do not set an identifier, one is automatically generated for you using hashed information from $_SERVER , including REQUEST_TIME_FLOAT , HTTP_X_FORWARDED_FOR , and/or REMOTE_ADDR .","title":"Processors"},{"location":"processors/#processors","text":"Processors allow you to provide additional information to logs in an automated fashion. They are called from the logger before the event is passed to the writers; they receive the event array, and return an event array on completion. Use cases include: Providing exception backtrace information. Injecting substitutions into the message. Injecting a request identifier (in order to later inspect logs for a specific identifier)","title":"Processors"},{"location":"processors/#processor-interface","text":"All processors must implement Zend\\Log\\Processor\\ProcessorInterface : namespace Zend\\Log\\Processor; interface ProcessorInterface { /** * Processes a log message before it is given to the writers * * @param array $event * @return array */ public function process(array $event); }","title":"Processor interface"},{"location":"processors/#adding-processors","text":"To add a processor to a Logger instance, inject it using the addProcessor() method: $logger->addProcessor(new Zend\\Log\\Processor\\Backtrace());","title":"Adding processors"},{"location":"processors/#available-processors","text":"The following processors are available.","title":"Available processors"},{"location":"processors/#backtrace","text":"Zend\\Log\\Processor\\Backtrace calls debug_backtrace() for every log event, injecting the details into the event's extra array: $event = [ // ... standard elements ... 'extra' => [ 'file' => 'SomeFile.php', 'line' => 1337, 'class' => 'Foo\\MyClass', 'function' => 'myMethod', ], ]; By default, classes under the Zend\\Log namespace are excluded from the backtrace that is logged so that the actual application code triggering the log event can be identified. You can add your own excluded namespaces to the backtrace processor by passing options into the constructor (note the required escaping of the \\ ): $processor = new Zend\\Log\\Processor\\Backtrace(['ignoredNamespaces' => ['Foo\\\\Log']]); $logger->addProcessor($processor); Alternatively, if not separately instantiating the processor, these options can be passed as the third argument to the logger's addProcessor() function: // Assuming the default processor priority of 1 $logger->addProcessor('backtrace', 1, ['ignoredNamespaces' => ['Foo\\\\Log']]);","title":"Backtrace"},{"location":"processors/#psrplaceholder","text":"Zend\\Log\\Processor\\PsrPlaceholder replaces PSR-3 -formatted message placeholders with the values found in the extra array. As an example: $logger->addProcessor(new Zend\\Log\\Processor\\PsrPlaceholder()); $logger->warn('Invalid plugin {plugin}', ['plugin' => 'My\\Plugins\\FooPlugin']); will output: Invalid plugin My\\Plugins\\FooPlugin This feature allows compatibility with PSR-3, and provides a simple way to provide string substitutions without needing to resort to sprintf() in your userland code.","title":"PsrPlaceholder"},{"location":"processors/#referenceid","text":"Zend\\Log\\Processor\\ReferenceId allows you to specify a static reference identifier to inject in all log messages; typically, you will generate a new one for each request, to allow querying logs for the given reference identifier later. Given the following: $processor = new Zend\\Log\\Processor\\ReferenceId(); $processor->setIdentifier(microtime(true) . '_' . uniqid()); $logger->addProcessor($processor); $logger->info('Log event'); The event will contain: $event = [ /* ... standard values ... */ 'extra' => [ 'referenceId' => '1455057110.6284_56ba68ebe1244', ], ];","title":"ReferenceId"},{"location":"processors/#requestid","text":"Zend\\Log\\Processor\\RequestId is similar to ReferenceId with one key difference: if you do not set an identifier, one is automatically generated for you using hashed information from $_SERVER , including REQUEST_TIME_FLOAT , HTTP_X_FORWARDED_FOR , and/or REMOTE_ADDR .","title":"RequestId"},{"location":"psr3/","text":"PSR-3 Logger Interface compatibility PSR-3 Logger Interface is a standards recommendation defining a common interface for logging libraries. The zend-log component predates it, and has minor incompatibilities, but starting with version 2.6 provides the following compatibility features: PSR logger adapter PSR logger writer PSR placeholder processor PsrLoggerAdapter Zend\\Log\\PsrLoggerAdapter wraps Zend\\Log\\LoggerInterface , allowing it to be used anywhere Psr\\Log\\LoggerInterface is expected. $zendLogLogger = new Zend\\Log\\Logger; $psrLogger = new Zend\\Log\\PsrLoggerAdapter($zendLogLogger); $psrLogger->log(Psr\\Log\\LogLevel::INFO, 'We have a PSR-compatible logger'); PSR-3 log writer Zend\\Log\\Writer\\Psr allows log messages and extras to be forwared to any PSR-3 compatible logger. As with any log writer, this has the added benefit that your filters can be used to limit forwarded messages. The writer needs a Psr\\Logger\\LoggerInterface instance to be useful, and falls back to Psr\\Log\\NullLogger if none is provided. There are three ways to provide the PSR logger instance to the log writer: // Via constructor parameter: $writer = new Zend\\Log\\Writer\\Psr($psrLogger); // Via option: $writer = new Zend\\Log\\Writer\\Psr(['logger' => $psrLogger]); // Via setter injection: $writer = new Zend\\Log\\Writer\\Psr(); $writer->setLogger($psrLogger); PSR-3 placeholder processor Zend\\Log\\Processor\\PsrPlaceholder adds support for PSR-3 message placeholders . Placeholder names correspond to keys in the \"extra\" array passed when logging a message. Values can be of arbitrary type, including all scalars, and objects implementing __toString ; objects not capable of string serialization will result in the fully-qualified class name being substituted. $logger = new Zend\\Log\\Logger; $logger->addProcessor(new Zend\\Log\\Processor\\PsrPlaceholder); $logger->info('User with email {email} registered', ['email' => 'user@example.org']); // logs message 'User with email user@example.org registered'","title":"PSR-3 Support"},{"location":"psr3/#psr-3-logger-interface-compatibility","text":"PSR-3 Logger Interface is a standards recommendation defining a common interface for logging libraries. The zend-log component predates it, and has minor incompatibilities, but starting with version 2.6 provides the following compatibility features: PSR logger adapter PSR logger writer PSR placeholder processor","title":"PSR-3 Logger Interface compatibility"},{"location":"psr3/#psrloggeradapter","text":"Zend\\Log\\PsrLoggerAdapter wraps Zend\\Log\\LoggerInterface , allowing it to be used anywhere Psr\\Log\\LoggerInterface is expected. $zendLogLogger = new Zend\\Log\\Logger; $psrLogger = new Zend\\Log\\PsrLoggerAdapter($zendLogLogger); $psrLogger->log(Psr\\Log\\LogLevel::INFO, 'We have a PSR-compatible logger');","title":"PsrLoggerAdapter"},{"location":"psr3/#psr-3-log-writer","text":"Zend\\Log\\Writer\\Psr allows log messages and extras to be forwared to any PSR-3 compatible logger. As with any log writer, this has the added benefit that your filters can be used to limit forwarded messages. The writer needs a Psr\\Logger\\LoggerInterface instance to be useful, and falls back to Psr\\Log\\NullLogger if none is provided. There are three ways to provide the PSR logger instance to the log writer: // Via constructor parameter: $writer = new Zend\\Log\\Writer\\Psr($psrLogger); // Via option: $writer = new Zend\\Log\\Writer\\Psr(['logger' => $psrLogger]); // Via setter injection: $writer = new Zend\\Log\\Writer\\Psr(); $writer->setLogger($psrLogger);","title":"PSR-3 log writer"},{"location":"psr3/#psr-3-placeholder-processor","text":"Zend\\Log\\Processor\\PsrPlaceholder adds support for PSR-3 message placeholders . Placeholder names correspond to keys in the \"extra\" array passed when logging a message. Values can be of arbitrary type, including all scalars, and objects implementing __toString ; objects not capable of string serialization will result in the fully-qualified class name being substituted. $logger = new Zend\\Log\\Logger; $logger->addProcessor(new Zend\\Log\\Processor\\PsrPlaceholder); $logger->info('User with email {email} registered', ['email' => 'user@example.org']); // logs message 'User with email user@example.org registered'","title":"PSR-3 placeholder processor"},{"location":"service-manager/","text":"Service Manager The zend-log package provides several components which can be used in combination with zend-servicemanager . These components make it possible to quickly setup a logger instance or to provide custom writers, filters, formatters, or processors. LoggerAbstractServiceFactory When you register the abstract factory called Zend\\Log\\LoggerAbstractServiceFactory , you will be able to setup loggers via the configuration. The abstract factory can be registered in the service manager using the following configuration: // module.config.php return [ 'service_manager' => [ 'abstract_factories' => [ 'Zend\\Log\\LoggerAbstractServiceFactory', ], ], ]; Users of zend-component-installer If you are using zend-component-installer, you will have been prompted to install zend-log as a module or configuration provider when you installed zend-log. When you do, the abstract factory is automatically registered for you in your configuration. zend-log as a module If you are using zend-log v2.8 or later with a zend-mvc-based application, but not using zend-component-installer, you can register Zend\\Log as a module in your application. When you do, the abstract service factory will be registered automatically. Next, define your custom loggers in the configuration as follows: // module.config.php return [ 'log' => [ 'MyLogger' => [ 'writers' => [ 'stream' => [ 'name' => 'stream', 'priority' => 1, 'options' => [ 'stream' => 'php://output', 'formatter' => [ 'name' => \\Zend\\Log\\Formatter\\Simple::class, 'options' => [ 'format' => '%timestamp% %priorityName% (%priority%): %message% %extra%', 'dateTimeFormat' => 'c', ], ], 'filters' => [ 'priority' => [ 'name' => 'priority', 'options' => [ 'operator' => '<=', 'priority' => \\Zend\\Log\\Logger::INFO, ], ], ], ], ], ], 'processors' => [ 'requestid' => [ 'name' => \\Zend\\Log\\Processor\\RequestId::class, ], ], ], ], ]; The logger can now be retrieved via the service manager using the key used in the configuration ( MyLogger ): /** @var \\Zend\\Log\\Logger $logger */ $logger = $container->get('MyLogger'); For the formatter and the filters, only the name is required, the options have default values (the values set in this example are the default ones). When only the name is needed, a shorter format can be used: // module.config.php 'options' => [ 'stream' => 'php://output', 'formatter' => \\Zend\\Log\\Formatter\\Simple::class, 'filters' => [ 'priority' => \\Zend\\Log\\Filter\\Priority::class, ], ], ]; Because the main filter is Priority , it can be set directly too: // module.config.php 'filters' => \\Zend\\Log\\Logger::INFO, ]; Custom Writers, Formatters, Filters, and Processors In the LoggerAbstractServiceFactory example above, a custom formatter (called MyFormatter ) and a custom filter (called MyFilter ) are used. These classes need to be made available to the service manager. It's possible to do this via custom plugin managers which have the names: log_formatters log_filters log_processors log_writers Example // module.config.php return [ 'log_formatters' => [ 'factories' => [ // ... ], ], 'log_filters' => [ 'factories' => [ // ... ], ], 'log_processors' => [ 'factories' => [ // ... ], ], 'log_writers' => [ 'factories' => [ // ... ], ], ];","title":"Service Manager Integration"},{"location":"service-manager/#service-manager","text":"The zend-log package provides several components which can be used in combination with zend-servicemanager . These components make it possible to quickly setup a logger instance or to provide custom writers, filters, formatters, or processors.","title":"Service Manager"},{"location":"service-manager/#loggerabstractservicefactory","text":"When you register the abstract factory called Zend\\Log\\LoggerAbstractServiceFactory , you will be able to setup loggers via the configuration. The abstract factory can be registered in the service manager using the following configuration: // module.config.php return [ 'service_manager' => [ 'abstract_factories' => [ 'Zend\\Log\\LoggerAbstractServiceFactory', ], ], ];","title":"LoggerAbstractServiceFactory"},{"location":"service-manager/#users-of-zend-component-installer","text":"If you are using zend-component-installer, you will have been prompted to install zend-log as a module or configuration provider when you installed zend-log. When you do, the abstract factory is automatically registered for you in your configuration.","title":"Users of zend-component-installer"},{"location":"service-manager/#zend-log-as-a-module","text":"If you are using zend-log v2.8 or later with a zend-mvc-based application, but not using zend-component-installer, you can register Zend\\Log as a module in your application. When you do, the abstract service factory will be registered automatically. Next, define your custom loggers in the configuration as follows: // module.config.php return [ 'log' => [ 'MyLogger' => [ 'writers' => [ 'stream' => [ 'name' => 'stream', 'priority' => 1, 'options' => [ 'stream' => 'php://output', 'formatter' => [ 'name' => \\Zend\\Log\\Formatter\\Simple::class, 'options' => [ 'format' => '%timestamp% %priorityName% (%priority%): %message% %extra%', 'dateTimeFormat' => 'c', ], ], 'filters' => [ 'priority' => [ 'name' => 'priority', 'options' => [ 'operator' => '<=', 'priority' => \\Zend\\Log\\Logger::INFO, ], ], ], ], ], ], 'processors' => [ 'requestid' => [ 'name' => \\Zend\\Log\\Processor\\RequestId::class, ], ], ], ], ]; The logger can now be retrieved via the service manager using the key used in the configuration ( MyLogger ): /** @var \\Zend\\Log\\Logger $logger */ $logger = $container->get('MyLogger'); For the formatter and the filters, only the name is required, the options have default values (the values set in this example are the default ones). When only the name is needed, a shorter format can be used: // module.config.php 'options' => [ 'stream' => 'php://output', 'formatter' => \\Zend\\Log\\Formatter\\Simple::class, 'filters' => [ 'priority' => \\Zend\\Log\\Filter\\Priority::class, ], ], ]; Because the main filter is Priority , it can be set directly too: // module.config.php 'filters' => \\Zend\\Log\\Logger::INFO, ];","title":"zend-log as a module"},{"location":"service-manager/#custom-writers-formatters-filters-and-processors","text":"In the LoggerAbstractServiceFactory example above, a custom formatter (called MyFormatter ) and a custom filter (called MyFilter ) are used. These classes need to be made available to the service manager. It's possible to do this via custom plugin managers which have the names: log_formatters log_filters log_processors log_writers","title":"Custom Writers, Formatters, Filters, and Processors"},{"location":"service-manager/#example","text":"// module.config.php return [ 'log_formatters' => [ 'factories' => [ // ... ], ], 'log_filters' => [ 'factories' => [ // ... ], ], 'log_processors' => [ 'factories' => [ // ... ], ], 'log_writers' => [ 'factories' => [ // ... ], ], ];","title":"Example"},{"location":"writers/","text":"Writers A writer is an object that inherits from Zend\\Log\\Writer\\AbstractWriter . A writer's responsibility is to record log data to a storage backend. Writing to Streams Zend\\Log\\Writer\\Stream sends log data to a PHP stream . To write log data to the PHP output buffer, use the php://output stream. Alternately, you can send log data directly to a stream like STDERR ( php://stderr ). $writer = new Zend\\Log\\Writer\\Stream('php://output'); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); To write data to a file, use one of the filesystem streams : $writer = new Zend\\Log\\Writer\\Stream('/path/to/logfile'); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); By default, the stream opens in the append access mode (\"a\"). To open it with a different access mode, the Zend\\Log\\Writer\\Stream constructor accepts an optional second parameter for the stream mode. The constructor of Zend\\Log\\Writer\\Stream also accepts an existing stream resource: $stream = @fopen('/path/to/logfile', 'a', false); if (! $stream) { throw new Exception('Failed to open stream'); } $writer = new Zend\\Log\\Writer\\Stream($stream); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); You cannot specify the stream access mode for existing stream resources. Doing so causes a Zend\\Log\\Exception to be thrown. You can use an array of options in place of the stream argument when constructing a Stream instance; when doing so, the stream key is required: $writer = new Zend\\Log\\Writer\\Stream([ 'stream' => 'php://output', ]); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); The following table details all allowed constructor arguments and their corresponding configuration options. Constructor Argument Option Name Default Description $streamOrUrl stream None; required Stream resource or URL to open and log to $mode mode \"a\" Stream access mode to use when opening a stream URL $logSeparator log_separator PHP_EOL Separator string to use between entries $filePermissions chmod null Permissions mode to use for stream resource; defaults to existing file/stream permissions Writing to Databases Zend\\Log\\Writer\\Db writes log information to a database table using Zend\\Db\\Adapter\\Adapter . The constructor of Zend\\Log\\Writer\\Db receives a Zend\\Db\\Adapter\\Adapter instance, a table name, an optional mapping of event data to database columns, and an optional string contains the character separator for the log array: $dbconfig = [ // Sqlite Configuration 'driver' => 'Pdo', 'dsn' => 'sqlite:' . __DIR__ . '/tmp/sqlite.db', ]; $db = new Zend\\Db\\Adapter\\Adapter($dbconfig); $writer = new Zend\\Log\\Writer\\Db($db, 'log_table_name'); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); The example above writes a single row of log data to the database table named log_table_name table. The database columns will be created according to the event array generated by the Zend\\Log\\Logger instance. If we specify the mapping of the events with the database columns, the log will store only to the selected fields in the database: $dbconfig = [ // Sqlite Configuration 'driver' => 'Pdo', 'dsn' => 'sqlite:' . __DIR__ . '/tmp/sqlite.db', ]; $db = new Zend\\Db\\Adapter\\Adapter($dbconfig); $mapping = [ 'timestamp' => 'date', 'priority' => 'type', 'message' => 'event', ]; $writer = new Zend\\Log\\Writer\\Db($db, 'log_table_name', $mapping); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); In this example, the writer stores only the log timestamp, priority, and message, in the database fields date, type, and event, respectively. Zend\\Log\\Writer\\Db has a fourth optional parameter in the constructor. This parameter is the character separator for array fields in the log event. For instance, if we have a log event that contains the field extra , and that field is an array, its elements will be translated as 'extra-field', where '-' is the character separator (default), and 'field' is the subname of the specific field found in the extra array. Writing to FirePHP Zend\\Log\\Writer\\FirePHP writes log information to the FirePHP Firefox extension. In order to use it, you must install the FirePHPCore server library and the FirePHP browser extension. To install the FirePHPCore library you can use Composer : $ composer require firephp/firephp-core Writing to ChromePHP Zend\\Log\\Writer\\ChromePHP sends log data to the ChromePHP Chrome extension. To use the ChromePHP writer, you will also need to include the ChromePHP Library library in your application. Use Composer to do this: $ composer require ccampbell/chromephp Writing to Mail Zend\\Log\\Writer\\Mail takes a configuration array or Zend\\Mail\\Message . Basic usage looks like $message = new \\Zend\\Mail\\Message(); $message->setTo('email@example.com'); $writer = new \\Zend\\Log\\Writer\\Mail($message); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to mail message $logger->info('Informational message'); An email of the logged information will be sent via sendmail by default. You may also provide a Zend\\Mail\\Transport during construction. For configuration options checkout the Zend\\Mail\\Transport documentation. $writer = new Zend\\Log\\Writer\\Mail($mail, $transport); Zend\\Log\\Writer\\mail may also be constructed with a configuration array. The configuration array accepts the following keys: [ 'subject_prepend_text' => '', 'transport' => $transport 'mail' => $mail, 'filters' => [], 'formatter' => [] ] And expects the following data: Array Index Accepted Values Description subject_prepend_text string Mail message transport Transport\\TransportInterface Transport method mail Zend\\Mail\\Message mail message mail array Zend\\Mail\\Message factory array filters array, int, string, Zend\\Log\\Filter\\FilterInterface Log filter(s) formatter array, string, Zend\\Log\\Formatter\\FormatterInterface Log formatter(s) Basic usage of the configuration array looks like: $transport = new \\Zend\\Mail\\Transport\\Smtp(); // TODO configure the SMTP transport $message = new \\Zend\\Mail\\Message(); // TODO configure the Mail message $writer = new \\Zend\\Log\\Writer\\Mail([ 'subject_prepend_text' => 'Start of the subject', 'transport' => $transport, 'mail' => $mail, 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to mail message $logger->info('Informational message'); To use the Zend\\Mail\\Message factory array construction will look like: $transport = new \\Zend\\Mail\\Transport\\Smtp(); // TODO configure the SMTP transport $writer = new \\Zend\\Log\\Writer\\Mail([ 'subject_prepend_text' => 'Start of the subject', 'transport' => $transport, 'mail' => [ 'to' => 'email@example.com' ], 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to mail message $logger->info('Informational message'); Writing to MongoDB Using the legacy mongo php driver (may be used up to up to php 5.6) In this example Zend\\Log\\Writer\\MongoDB uses an array for construction. Available keys include: [ 'save_options' => [], 'collection' => '', 'database' => '', 'mongo' => $mongo, 'filters' => [], 'formatter' => [] ] collection , database , and mongo are required. Each key accepts: Array Index Accepted Values Description save_options array MongoDB driver options collection string collection name database string database name mongo Mongo or MongoClient MongoDB connection object filters array, int, string, Zend\\Log\\Filter\\FilterInterface Log filter(s) formatter array, string, Zend\\Log\\Formatter\\FormatterInterface Log formatter(s) And Zend\\Log\\Writer\\MongoDB is used like this: $mongo = new MongoClient(); $writer = new \\Zend\\Log\\Writer\\MongoDB([ 'save_options' => [], // MongoDB Driver Options 'collection' => 'collectionName', 'database' => 'databaseName', 'mongo' => $mongo, 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Mongo DB $logger->info('Informational message'); It may also be constructed by passing the arguments directly $mongo = new MongoClient(); $database = 'databaseName'; $collection = 'collectionName'; $saveOptions = []; $writer = new \\Zend\\Log\\Writer\\MongoDB($mongo, $database, $collection, $saveOptions); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Mongo DB $logger->info('Informational message'); Using the mongodb driver (php 5.4 and later) In this example Zend\\Log\\Writer\\MongoDB uses an array for construction. Available keys include: [ 'save_options' => [], 'collection' => '', 'database' => '', 'manager' => $mongo, 'filters' => [], 'formatter' => [] ] collection , database , and manager are required. Each key accepts: Array Index Accepted Values Description save_options array MongoDB driver options collection string collection name database string database name manager MongoDB\\Driver\\Manager MongoDB connection object filters array, int, string, Zend\\Log\\Filter\\FilterInterface Log filter(s) formatter array, string, Zend\\Log\\Formatter\\FormatterInterface Log formatter(s) And Zend\\Log\\Writer\\MongoDB is used like this: $mongo = new MongoDB\\Driver\\Manager(); $writer = new \\Zend\\Log\\Writer\\MongoDB([ 'save_options' => [], // MongoDB Driver Options 'collection' => 'collectionName', 'database' => 'databaseName', 'manager' => $mongo, 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Mongo DB $logger->info('Informational message'); It may also be constructed by passing the arguments directly $mongo = new MongoDB\\Driver\\Manager(); $database = 'databaseName'; $collection = 'collectionName'; $saveOptions = []; $writer = new \\Zend\\Log\\Writer\\MongoDB($manager, $database, $collection, $saveOptions); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Mongo DB $logger->info('Informational message'); Writing to Syslog Zend\\Log\\Writer\\Syslog is a writer generates system log messages from the data it receives. $writer = new \\Zend\\Log\\Writer\\Syslog(); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to system log $logger->info('Informational message'); The application name and syslog facility may be set Array Index Accepted Values Description application string application name facility string syslog facility (list of facilities)[http://php.net/openlog] filters array, int, string, Zend\\Log\\Filter\\FilterInterface Log filter(s) formatter array, string, Zend\\Log\\Formatter\\FormatterInterface Log formatter(s) $writer = new \\Zend\\Log\\Writer\\Syslog([ 'application' => '', 'facility' => '', 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); Writing to Zend Monitor Zend\\Log\\Writer\\ZendMonitor writes log data to the Zend Monitor on a Zend Server. If the web server is not a Zend Server or Zend Monitor is not enabled it will fail silently. $writer = new \\Zend\\Log\\Writer\\ZendMonitor(); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Zend Monitor $logger->info('Informational message'); Zend\\Log\\Writer\\AbstractWriter options are available. Array Index Accepted Values Description filters array, int, string, Zend\\Log\\Filter\\FilterInterface Log filter(s) formatter array, string, Zend\\Log\\Formatter\\FormatterInterface Log formatter(s) $writer = new \\Zend\\Log\\Writer\\ZendMonitor([ 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Zend Monitor $logger->info('Informational message'); Stubbing Out the Writer Zend\\Log\\Writer\\Noop is a stub that does not write log data to anything; it is useful for disabling logging or stubbing out logging during tests: $writer = new Zend\\Log\\Writer\\Noop; $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); // goes nowhere $logger->info('Informational message'); Migration from 2.0-2.3 to 2.4+ Version 2.4 adds support for PHP 7. In PHP 7, null is a reserved keyword, which required renaming the Null log writer. If you were using the Null writer directly previously, you will now receive an E_USER_DEPRECATED notice on instantiation. Please update your code to refer to the Noop class instead. Users pulling their Null writer instance from the writer plugin manager receive a Noop instance instead starting in 2.4.0. Testing with the Mock Writer Zend\\Log\\Writer\\Mock is a simple writer that records the raw data it receives in an array that it exposes as a public property. $mock = new Zend\\Log\\Writer\\Mock; $logger = new Zend\\Log\\Logger(); $logger->addWriter($mock); $logger->info('Informational message'); var_dump($mock->events[0]); // Array // ( // [timestamp] => 2007-04-06T07:16:37-07:00 // [message] => Informational message // [priority] => 6 // [priorityName] => INFO // ) To clear the events logged by the mock, reset the $events property: $mock->events = []; Compositing Writers There is no composite writer object. However, a Logger instance can write to any number of writers, effectively making it a composite logger. To utilize this functionality, add writers via the Logger::addWriter() method: $writer1 = new Zend\\Log\\Writer\\Stream('/path/to/first/logfile'); $writer2 = new Zend\\Log\\Writer\\Stream('/path/to/second/logfile'); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer1); $logger->addWriter($writer2); // goes to both writers $logger->info('Informational message'); You can also specify the priority number for each writer to change the order of writing. The priority number is an integer number passed as second parameter in the addWriter() method. Internally, SplPriorityQueue is used to manage writers, which means that: higher integer values indicate higher priority (triggered earliest); lower integer values (including negative values) have lower priority (triggered last). Distinction between priority in the queue of writers and the filter Priority When you add a writer to the logger, you can set its priority as a second argument. This priority is the priority in the queue of all writers of the logger. It can be any integer, and the default is 1 ( \\Zend\\Log\\Logger::ALERT ) for the writers; the bigger the number, the higher the priority. A writer with a lower priority will be triggered later, so ALERT is triggered after DEBUG . For details on the list of the priorities, see the section entitled Using Built-in Priorities . This priority should not be confused with the Priority filter , which determines if a message meets a severity threshold. When a Priority filter is attached, the writer will output the message only when the filter is lower or equal (by default) to the priority (the biggest severity is 0).","title":"Writers"},{"location":"writers/#writers","text":"A writer is an object that inherits from Zend\\Log\\Writer\\AbstractWriter . A writer's responsibility is to record log data to a storage backend.","title":"Writers"},{"location":"writers/#writing-to-streams","text":"Zend\\Log\\Writer\\Stream sends log data to a PHP stream . To write log data to the PHP output buffer, use the php://output stream. Alternately, you can send log data directly to a stream like STDERR ( php://stderr ). $writer = new Zend\\Log\\Writer\\Stream('php://output'); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); To write data to a file, use one of the filesystem streams : $writer = new Zend\\Log\\Writer\\Stream('/path/to/logfile'); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); By default, the stream opens in the append access mode (\"a\"). To open it with a different access mode, the Zend\\Log\\Writer\\Stream constructor accepts an optional second parameter for the stream mode. The constructor of Zend\\Log\\Writer\\Stream also accepts an existing stream resource: $stream = @fopen('/path/to/logfile', 'a', false); if (! $stream) { throw new Exception('Failed to open stream'); } $writer = new Zend\\Log\\Writer\\Stream($stream); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); You cannot specify the stream access mode for existing stream resources. Doing so causes a Zend\\Log\\Exception to be thrown. You can use an array of options in place of the stream argument when constructing a Stream instance; when doing so, the stream key is required: $writer = new Zend\\Log\\Writer\\Stream([ 'stream' => 'php://output', ]); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); The following table details all allowed constructor arguments and their corresponding configuration options. Constructor Argument Option Name Default Description $streamOrUrl stream None; required Stream resource or URL to open and log to $mode mode \"a\" Stream access mode to use when opening a stream URL $logSeparator log_separator PHP_EOL Separator string to use between entries $filePermissions chmod null Permissions mode to use for stream resource; defaults to existing file/stream permissions","title":"Writing to Streams"},{"location":"writers/#writing-to-databases","text":"Zend\\Log\\Writer\\Db writes log information to a database table using Zend\\Db\\Adapter\\Adapter . The constructor of Zend\\Log\\Writer\\Db receives a Zend\\Db\\Adapter\\Adapter instance, a table name, an optional mapping of event data to database columns, and an optional string contains the character separator for the log array: $dbconfig = [ // Sqlite Configuration 'driver' => 'Pdo', 'dsn' => 'sqlite:' . __DIR__ . '/tmp/sqlite.db', ]; $db = new Zend\\Db\\Adapter\\Adapter($dbconfig); $writer = new Zend\\Log\\Writer\\Db($db, 'log_table_name'); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); The example above writes a single row of log data to the database table named log_table_name table. The database columns will be created according to the event array generated by the Zend\\Log\\Logger instance. If we specify the mapping of the events with the database columns, the log will store only to the selected fields in the database: $dbconfig = [ // Sqlite Configuration 'driver' => 'Pdo', 'dsn' => 'sqlite:' . __DIR__ . '/tmp/sqlite.db', ]; $db = new Zend\\Db\\Adapter\\Adapter($dbconfig); $mapping = [ 'timestamp' => 'date', 'priority' => 'type', 'message' => 'event', ]; $writer = new Zend\\Log\\Writer\\Db($db, 'log_table_name', $mapping); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message'); In this example, the writer stores only the log timestamp, priority, and message, in the database fields date, type, and event, respectively. Zend\\Log\\Writer\\Db has a fourth optional parameter in the constructor. This parameter is the character separator for array fields in the log event. For instance, if we have a log event that contains the field extra , and that field is an array, its elements will be translated as 'extra-field', where '-' is the character separator (default), and 'field' is the subname of the specific field found in the extra array.","title":"Writing to Databases"},{"location":"writers/#writing-to-firephp","text":"Zend\\Log\\Writer\\FirePHP writes log information to the FirePHP Firefox extension. In order to use it, you must install the FirePHPCore server library and the FirePHP browser extension. To install the FirePHPCore library you can use Composer : $ composer require firephp/firephp-core","title":"Writing to FirePHP"},{"location":"writers/#writing-to-chromephp","text":"Zend\\Log\\Writer\\ChromePHP sends log data to the ChromePHP Chrome extension. To use the ChromePHP writer, you will also need to include the ChromePHP Library library in your application. Use Composer to do this: $ composer require ccampbell/chromephp","title":"Writing to ChromePHP"},{"location":"writers/#writing-to-mail","text":"Zend\\Log\\Writer\\Mail takes a configuration array or Zend\\Mail\\Message . Basic usage looks like $message = new \\Zend\\Mail\\Message(); $message->setTo('email@example.com'); $writer = new \\Zend\\Log\\Writer\\Mail($message); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to mail message $logger->info('Informational message'); An email of the logged information will be sent via sendmail by default. You may also provide a Zend\\Mail\\Transport during construction. For configuration options checkout the Zend\\Mail\\Transport documentation. $writer = new Zend\\Log\\Writer\\Mail($mail, $transport); Zend\\Log\\Writer\\mail may also be constructed with a configuration array. The configuration array accepts the following keys: [ 'subject_prepend_text' => '', 'transport' => $transport 'mail' => $mail, 'filters' => [], 'formatter' => [] ] And expects the following data: Array Index Accepted Values Description subject_prepend_text string Mail message transport Transport\\TransportInterface Transport method mail Zend\\Mail\\Message mail message mail array Zend\\Mail\\Message factory array filters array, int, string, Zend\\Log\\Filter\\FilterInterface Log filter(s) formatter array, string, Zend\\Log\\Formatter\\FormatterInterface Log formatter(s) Basic usage of the configuration array looks like: $transport = new \\Zend\\Mail\\Transport\\Smtp(); // TODO configure the SMTP transport $message = new \\Zend\\Mail\\Message(); // TODO configure the Mail message $writer = new \\Zend\\Log\\Writer\\Mail([ 'subject_prepend_text' => 'Start of the subject', 'transport' => $transport, 'mail' => $mail, 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to mail message $logger->info('Informational message'); To use the Zend\\Mail\\Message factory array construction will look like: $transport = new \\Zend\\Mail\\Transport\\Smtp(); // TODO configure the SMTP transport $writer = new \\Zend\\Log\\Writer\\Mail([ 'subject_prepend_text' => 'Start of the subject', 'transport' => $transport, 'mail' => [ 'to' => 'email@example.com' ], 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to mail message $logger->info('Informational message');","title":"Writing to Mail"},{"location":"writers/#writing-to-mongodb","text":"Using the legacy mongo php driver (may be used up to up to php 5.6) In this example Zend\\Log\\Writer\\MongoDB uses an array for construction. Available keys include: [ 'save_options' => [], 'collection' => '', 'database' => '', 'mongo' => $mongo, 'filters' => [], 'formatter' => [] ] collection , database , and mongo are required. Each key accepts: Array Index Accepted Values Description save_options array MongoDB driver options collection string collection name database string database name mongo Mongo or MongoClient MongoDB connection object filters array, int, string, Zend\\Log\\Filter\\FilterInterface Log filter(s) formatter array, string, Zend\\Log\\Formatter\\FormatterInterface Log formatter(s) And Zend\\Log\\Writer\\MongoDB is used like this: $mongo = new MongoClient(); $writer = new \\Zend\\Log\\Writer\\MongoDB([ 'save_options' => [], // MongoDB Driver Options 'collection' => 'collectionName', 'database' => 'databaseName', 'mongo' => $mongo, 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Mongo DB $logger->info('Informational message'); It may also be constructed by passing the arguments directly $mongo = new MongoClient(); $database = 'databaseName'; $collection = 'collectionName'; $saveOptions = []; $writer = new \\Zend\\Log\\Writer\\MongoDB($mongo, $database, $collection, $saveOptions); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Mongo DB $logger->info('Informational message'); Using the mongodb driver (php 5.4 and later) In this example Zend\\Log\\Writer\\MongoDB uses an array for construction. Available keys include: [ 'save_options' => [], 'collection' => '', 'database' => '', 'manager' => $mongo, 'filters' => [], 'formatter' => [] ] collection , database , and manager are required. Each key accepts: Array Index Accepted Values Description save_options array MongoDB driver options collection string collection name database string database name manager MongoDB\\Driver\\Manager MongoDB connection object filters array, int, string, Zend\\Log\\Filter\\FilterInterface Log filter(s) formatter array, string, Zend\\Log\\Formatter\\FormatterInterface Log formatter(s) And Zend\\Log\\Writer\\MongoDB is used like this: $mongo = new MongoDB\\Driver\\Manager(); $writer = new \\Zend\\Log\\Writer\\MongoDB([ 'save_options' => [], // MongoDB Driver Options 'collection' => 'collectionName', 'database' => 'databaseName', 'manager' => $mongo, 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Mongo DB $logger->info('Informational message'); It may also be constructed by passing the arguments directly $mongo = new MongoDB\\Driver\\Manager(); $database = 'databaseName'; $collection = 'collectionName'; $saveOptions = []; $writer = new \\Zend\\Log\\Writer\\MongoDB($manager, $database, $collection, $saveOptions); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Mongo DB $logger->info('Informational message');","title":"Writing to MongoDB"},{"location":"writers/#writing-to-syslog","text":"Zend\\Log\\Writer\\Syslog is a writer generates system log messages from the data it receives. $writer = new \\Zend\\Log\\Writer\\Syslog(); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to system log $logger->info('Informational message'); The application name and syslog facility may be set Array Index Accepted Values Description application string application name facility string syslog facility (list of facilities)[http://php.net/openlog] filters array, int, string, Zend\\Log\\Filter\\FilterInterface Log filter(s) formatter array, string, Zend\\Log\\Formatter\\FormatterInterface Log formatter(s) $writer = new \\Zend\\Log\\Writer\\Syslog([ 'application' => '', 'facility' => '', 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); $logger->info('Informational message');","title":"Writing to Syslog"},{"location":"writers/#writing-to-zend-monitor","text":"Zend\\Log\\Writer\\ZendMonitor writes log data to the Zend Monitor on a Zend Server. If the web server is not a Zend Server or Zend Monitor is not enabled it will fail silently. $writer = new \\Zend\\Log\\Writer\\ZendMonitor(); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Zend Monitor $logger->info('Informational message'); Zend\\Log\\Writer\\AbstractWriter options are available. Array Index Accepted Values Description filters array, int, string, Zend\\Log\\Filter\\FilterInterface Log filter(s) formatter array, string, Zend\\Log\\Formatter\\FormatterInterface Log formatter(s) $writer = new \\Zend\\Log\\Writer\\ZendMonitor([ 'filters' => [], 'formatter' => [] ]); $logger = new \\Zend\\Log\\Logger(); $logger->addWriter($writer); // goes to Zend Monitor $logger->info('Informational message');","title":"Writing to Zend Monitor"},{"location":"writers/#stubbing-out-the-writer","text":"Zend\\Log\\Writer\\Noop is a stub that does not write log data to anything; it is useful for disabling logging or stubbing out logging during tests: $writer = new Zend\\Log\\Writer\\Noop; $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer); // goes nowhere $logger->info('Informational message');","title":"Stubbing Out the Writer"},{"location":"writers/#migration-from-20-23-to-24","text":"Version 2.4 adds support for PHP 7. In PHP 7, null is a reserved keyword, which required renaming the Null log writer. If you were using the Null writer directly previously, you will now receive an E_USER_DEPRECATED notice on instantiation. Please update your code to refer to the Noop class instead. Users pulling their Null writer instance from the writer plugin manager receive a Noop instance instead starting in 2.4.0.","title":"Migration from 2.0-2.3 to 2.4+"},{"location":"writers/#testing-with-the-mock-writer","text":"Zend\\Log\\Writer\\Mock is a simple writer that records the raw data it receives in an array that it exposes as a public property. $mock = new Zend\\Log\\Writer\\Mock; $logger = new Zend\\Log\\Logger(); $logger->addWriter($mock); $logger->info('Informational message'); var_dump($mock->events[0]); // Array // ( // [timestamp] => 2007-04-06T07:16:37-07:00 // [message] => Informational message // [priority] => 6 // [priorityName] => INFO // ) To clear the events logged by the mock, reset the $events property: $mock->events = [];","title":"Testing with the Mock Writer"},{"location":"writers/#compositing-writers","text":"There is no composite writer object. However, a Logger instance can write to any number of writers, effectively making it a composite logger. To utilize this functionality, add writers via the Logger::addWriter() method: $writer1 = new Zend\\Log\\Writer\\Stream('/path/to/first/logfile'); $writer2 = new Zend\\Log\\Writer\\Stream('/path/to/second/logfile'); $logger = new Zend\\Log\\Logger(); $logger->addWriter($writer1); $logger->addWriter($writer2); // goes to both writers $logger->info('Informational message'); You can also specify the priority number for each writer to change the order of writing. The priority number is an integer number passed as second parameter in the addWriter() method. Internally, SplPriorityQueue is used to manage writers, which means that: higher integer values indicate higher priority (triggered earliest); lower integer values (including negative values) have lower priority (triggered last).","title":"Compositing Writers"},{"location":"writers/#distinction-between-priority-in-the-queue-of-writers-and-the-filter-priority","text":"When you add a writer to the logger, you can set its priority as a second argument. This priority is the priority in the queue of all writers of the logger. It can be any integer, and the default is 1 ( \\Zend\\Log\\Logger::ALERT ) for the writers; the bigger the number, the higher the priority. A writer with a lower priority will be triggered later, so ALERT is triggered after DEBUG . For details on the list of the priorities, see the section entitled Using Built-in Priorities . This priority should not be confused with the Priority filter , which determines if a message meets a severity threshold. When a Priority filter is attached, the writer will output the message only when the filter is lower or equal (by default) to the priority (the biggest severity is 0).","title":"Distinction between priority in the queue of writers and the filter Priority"}]}